version: '3'

# Глобальные переменные проекта
vars:
  GOFUMPT_VERSION: 'v0.8.0'
  GCI_VERSION: 'v0.13.6'
  GOLANGCI_LINT_VERSION: 'v2.1.5'
  YQ_VERSION: 'v4.45.2'
  OGEN_VERSION: 'v1.12.0'
  MOCKERY_VERSION: 'v2.53.3'

  # Директории
  BIN_DIR: '{{.ROOT_DIR}}/bin'
  GOLANGCI_LINT: '{{.BIN_DIR}}/golangci-lint'
  GCI: '{{.BIN_DIR}}/gci'
  GOFUMPT: '{{.BIN_DIR}}/gofumpt'
  YQ: '{{.BIN_DIR}}/yq'
  OGEN: '{{.BIN_DIR}}/ogen'
  MOCKERY: "{{.BIN_DIR}}/mockery"

  COVERAGE_DIR: '{{.ROOT_DIR}}/coverage'
  COVERAGE_FILE: total.out

  OPEN_API_FILES: '{{.ROOT_DIR}}/api/reviewer/v1'


tasks:
  deps:update:
    desc: "Обновление зависимостей в go.mod"
    cmds:
      - |
        echo "Обновляем зависимости в go.mod ..."
        go mod tidy -compat=1.24
        echo "Готово."

  install-formatters:
    desc: "Устанавливает форматтеры gci и gofumpt в ./bin"
    summary: |
      Эта задача проверяет наличие инструментов форматирования кода gofumpt и gci в директории bin.
      Если инструменты не найдены, они будут автоматически установлены с указанными версиями.

      Используется:
        - gofumpt: для форматирования кода Go
        - gci: для сортировки импортов Go
    cmds:
      - |
        [ -f {{.GOFUMPT}} ] || {
          echo 'Устанавливаем gofumpt {{.GOFUMPT_VERSION}}...'
          GOBIN={{.BIN_DIR}} go install mvdan.cc/gofumpt@{{.GOFUMPT_VERSION}}
        }
        [ -f {{.GCI}} ] || {
          echo 'Устанавливаем gci {{.GCI_VERSION}}...'
          GOBIN={{.BIN_DIR}} go install github.com/daixiang0/gci@{{.GCI_VERSION}}
        }
    status:
      - test -x {{.GOFUMPT}}
      - test -x {{.GCI}}

  format:
    desc: "Форматирует весь проект gofumpt + gci, исключая mocks"
    deps: [ install-formatters ]
    cmds:
      - |
        echo "Сортируем импорты через gci ..."
        
        find . -type f -name '*.go' ! -path '*/mocks/*' \
          -exec {{.GCI}} write --skip-generated -s standard -s default -s "prefix(github.com/ZanDattSu/pr-reviewer)" {} +

      - |
        echo "Форматируем через gofumpt ..."
        
        find . -type f -name '*.go' ! -path '*/mocks/*' \
          -exec {{.GOFUMPT}} -extra -w {} +

  install-golangci-lint:
    desc: "Устанавливает golangci-lint в каталог bin"
    summary: |
      Проверяет наличие golangci-lint в директории bin.
      Если инструмент не найден, автоматически устанавливает его через go install.

      Устанавливаемая версия: {{.GOLANGCI_LINT_VERSION}}
    cmds:
      - |
        [ -f {{.GOLANGCI_LINT}} ] || {
          mkdir -p {{.BIN_DIR}}
          echo "Устанавливаем golangci-lint {{.GOLANGCI_LINT_VERSION}}..."
          GOBIN={{.BIN_DIR}} go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@{{.GOLANGCI_LINT_VERSION}}
        }
    status:
      - test -x {{.GOLANGCI_LINT}}
  lint:
    desc: "Запускает golangci-lint для всего проекта"
    summary: |
      Запускает линтер golangci-lint для всего проекта.
      Линтер проверяет код на соответствие стандартам качества и лучшим практикам.

      Зависимости:
        - install-golangci-lint: автоматически устанавливает линтер
        - format: форматирует код перед проверкой
    deps: [ install-golangci-lint, format ]
    cmds:
      - |
        echo "Запускаем golangci-lint..."
        
        {{.GOLANGCI_LINT}} run ./... --config=.golangci.yml
        
        echo "Линтинг завершён успешно"

  yq:install:
    desc: "Устанавливает yq в bin/ при необходимости"
    cmds:
      - |
        [ -f {{.YQ}} ] || {
          echo 'Installing yq...'
          GOBIN={{.BIN_DIR}} go install github.com/mikefarah/yq/v4@{{.YQ_VERSION}}
        }

  ogen:install:
    desc: "Скачивает ogen в папку bin"
    cmds:
      - |
        [ -f {{.OGEN}} ] || {
          mkdir -p {{.BIN_DIR}}
          GOBIN={{.BIN_DIR}} go install github.com/ogen-go/ogen/cmd/ogen@{{.OGEN_VERSION}}
        }

  api:gen:
    desc: "Генерация Go-кода из всех OpenAPI-деклараций с x-ogen"
    deps: [ ogen:install, yq:install ]
    cmds:
      - |
        find {{.OPEN_API_FILES}} -name '*.yaml' -o -name '*.yml' | while read -r file; do
          if [ -f "$file" ] && grep -q 'x-ogen:' "$file"; then
            echo "Generating from: $file"
            target=$({{.YQ}} e '."x-ogen".target' "$file")
            package=$({{.YQ}} e '."x-ogen".package' "$file")
            echo "Target: $target"
            echo "Package: $package"
            {{.OGEN}} \
              --target "$target" \
              --package "$package" \
              --clean \
              "$file" || exit 1
          fi
        done

  up:
    desc: Поднять reviewer и все его зависимости
    cmds:
      - echo "[task] Поднимаем reviewer с зависимостями"
      - docker compose up --build --detach

  down:
    desc: Остановить reviewer сервис и все его зависимости
    cmds:
      - echo "[task] Останавливаем reviewer с зависимостями"
      - docker compose down

  mockery:install:
    desc: "Устанавливает mockery в ./bin"
    cmds:
      - |
        [ -f {{.MOCKERY}} ] || {
          echo 'Installing mockery...'
          GOBIN={{.BIN_DIR}} go install github.com/vektra/mockery/v2@{{.MOCKERY_VERSION}}
        }
    status:
      - test -x {{.MOCKERY}}

  mockery:gen:
    desc: "Генерирует моки интерфейсов с помощью mockery"
    deps: [ mockery:install ]
    cmds:
      - |
        echo 'Генерация моков...'
        {{.MOCKERY}}

  test:
    desc: "Тесты с покрытием бизнес-логики, автоматический поиск и анализ всех модулей"
    cmds:
      - |
        echo "Запускаем расчёт покрытия..."
        rm -rf {{.COVERAGE_DIR}}
        mkdir -p {{.COVERAGE_DIR}}
        
        TARGET_PACKAGES=$(go list ./internal/... | grep -v "/mocks" | grep -E '/service/' | tr '\n' ',')
        
        if [ -z "$TARGET_PACKAGES" ]; then
          echo "Не найдено пакетов для тестирования"
          exit 1
        fi
        
        echo "Запуск тестов со сбором покрытия..."
        go test -v -coverprofile={{.COVERAGE_DIR}}/coverage.out -coverpkg=$TARGET_PACKAGES ./...
        
        echo "Общее покрытие service слоя (бизнес-логика):"
        go tool cover -func={{.COVERAGE_DIR}}/coverage.out | tail -n1

  coverage:html:
    desc: "Генерирует HTML-отчёт покрытия и открывает его в браузере"
    deps: [ test-coverage ]
    cmds:
      - |
        OUTPUT={{.COVERAGE_DIR}}/coverage.html
        echo "Генерируем HTML-отчёт..."
        go tool cover -html={{.COVERAGE_DIR}}/coverage.out -o $OUTPUT
        
        echo "Открываем $OUTPUT"
        if command -v open &> /dev/null; then
          open $OUTPUT  # macOS
        elif command -v xdg-open &> /dev/null; then
          xdg-open $OUTPUT  # Linux
        else
          echo "Отчёт сохранён в $OUTPUT (открой вручную)"
        fi