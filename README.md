# Сервис автоматического назначения и управления ревьюверами для Pull Request’ов

Сервис управляет командами и пользователями, автоматически назначает ревьюверов для PR, поддерживает безопасное переназначение и массовую деактивацию пользователей с соблюдением доменных ограничений. Доступен по HTTP, контракт строго описан через OpenAPI.

### Требования

- **Go** ≥ `1.24`
- Docker
- **Taskfile CLI** → [инструкция по установке](https://taskfile.dev/#/installation)

### Быстрый старт
```shell
Для запуска проекта нужно выполнить одну из команд
 1. `task up`
 2. `docker-compose up`.
После этого сервис будет доступен на порту `:8080` #(можно изменить в .env)
```
---

#### Подключены golangci-lint линтер и форматтеры gci и gofumpt

- Их настройки подробно описаны в конце Readme.md
---

### Обособенности реализации

#### Архитектурные особенности

- Идемпотентные операции для критичных бизнес-действий

- Централизованная обработка ошибок с кодами домена

- Используется менеджер транзакций для вынесения логики работы с транзакциями в сервисный слой.

- Поддержка массовых операций (batch-деактивация пользователей)

#### Генерация OpenAPI: ogen

  - Используется ogen для генерации HTTP-хендлеров, моделей и валидации.
  - Главный плюс данного решения: исключает расхождения между контрактом и реализацией.
  - Так же стимулирует поддерживать документацию в актуальном состоянии.
  - Генерация вынесена в отдельный Task (task api:gen).

#### Taskfile

Файл с готовыми командами для генерации кода, моков, форматирования, линтинга, поднятия окружения, прогона тестов и других задач.
Полный список команд
```shell
task
```

#### Работа с конфигурацией через env-интерфейсы

  - Конфигурация маппится в go структуры через библиотеку `caarlos0/env`
  - Описана через интерфейсы и структуру-обёртку.
  - Удобно мокать на тестах, не привязываясь к конкретным переменным окружения.
  - Инициализация выполняется на старте через метод `Load()`.

#### Написана собственная обёртка над zap
  - Единый формат логов; 
  - Автоматическое обогащение логов (trace_id, user_id) из context.Context, для возможности собирать трейсы в будущем
  - Уровень логирования задается через .env
  - Единый формат вывода (JSON / Console), не нужно настраивать в новых сервисах.
  - Безопасная работа в тестах (NoopLogger, InitForBenchmark).

#### Graceful shutdown 
  - В проекте используется небольшая утилита для аккуратного завершения сервиса. Она решает несколько задач:
  
    - Централизованное управление остановкой сервиса (CloseAll). 
    - Позволяет регистрировать функции закрытия (БД, HTTP-сервер). 
    - Реагирует на системные сигналы (SIGINT, SIGTERM) и запускает shutdown.
    - Закрывает ресурсы в обратном порядке, что удобно, когда одни зависят от других.
    - Выполнение shutdown-функций **параллельно в горутинах** + **корректная синхронизация (Mutex, WaitGroup)**.
    - Безопасная **работа с каналами** и ошибками — **нет гонок и утечек**.
    - Защищён от повторных вызовов и ошибок: есть sync.Once, обработка panic и таймаут.
    - Показывает в логах, что именно закрывается и сколько времени это заняло.
    

#### Миграции через goose
  - Написана небольшая обертка над goose  

  - Схема БД проходит миграции через goose.
  - Миграции лежат в папке: `migrations/`.
  - При старте приложения запускает миграции 
  - Гарантируется повторяемость структуры БД в любом окружении.

#### Чистая архитектура
- Каждый слой имеет свои модели, интерфейсы и полностью изолирован от остальных

Разделение на слои:
- App - точка входа в приложение
  - Проброс конфигов
  - Автоматически инициализация зависимостей через **Dependency Injection** контейнер
- Api - HTTP хендлеры 
  - Принимает бизнес структуры сервисного слоя, обрабатывает их
  - Отдает сгенерированные ogen объекты
- Service - бизнес-логика, оперирует чисто сервисными моделями
- Repository - работает с хранилищами (PostgreSQL)
  - Имеет собственные модели, адаптированные под конкретные хранилища
  - Всю конвертацию делает внутри - интерфейс оперирует бизнес моделями сервисного слоя

Cтруктура проекта

```
├── api
│   ├── pkg - сгенерированный ogen код
│   └── reviewer - openApi
├── cmd - точка входа в сервис
├── internal
│   ├── api - HTTP хендлеры
│   ├── app - точка входа в приложение и dependency injection
│   ├── config - обертка над .env конфигами
│   ├── converter - консвертер service <=> api
│   ├── model - сущности сервисного слоя
│   ├── repository
│   ├── server - структура сервера
│   └── service - бизнес-логика
├── migrations - миграции
└── pkg
    ├── closer - утилита для graceful shutdown
    ├── logger - обертка над uber/zap
    └── migrator - обертка над goose
```

#### Unit-тесты бизнес логики, используя mockery

Unit-тесты покрывают бизнес-логику **без внешних зависимостей**.

Все внешние вызовы — **через интерфейсы и моки** (автоматическая генерация моков с помощью Mockery).

По всех unit тестах используются табличные тесты через **Test Suite** из `testify/suite`:

#### Docker Compose

Полностью автоматизирует поднятие инфраструктуры

- Использует плейсхолдеры для подстановки переменных окружения из .env
- Создает volumes для серсисов которые должны хранить состояние.
- Делает healthcheck, с политикой ретраев и автоматически перезапускает контейнер при сбоях
---

### Работа с БД

##### Структура БД

![DB.png](pr-reviewers-DB.png)

- Продумал структуру таблиц так, чтобы они строго отражали доменную модель.
- Нормализовал данные и исключил дублирование.
- Добавил нужные индексы под реальные запросы.
- Учитывал сценарии обновлений: UPDATE/SELECT внутри транзакций под Serializable.
---

### Основные сущности

**Team** — команда с уникальным именем и набором пользователей

**User** — участник команды с флагом активности is_active

**PullRequest (PR)** — pull request со статусом OPEN | MERGED и списком ревьюверов (0..2)

---

### Эндпоинты и бизнес-логика

---
### Health

#### `GET /health`
Проверяет работоспособность сервиса.

---

### Teams

#### `POST /team/add`
Создаёт команду и её участников.  
Если пользователь уже существует — обновляет его данные.

#### `GET /team/get?team_name={team_name}`
Возвращает команду и список её участников по имени команды.

---

### Users

#### `GET /users/stats`
Возвращает статистику количества Pull Request’ов по пользователям.

**Query params:**
- `top` — вернуть топ-N пользователей
- `only_active` — учитывать только активных пользователей
- `only_open` — учитывать только PR в статусе `OPEN`

#### `POST /users/setIsActive`
Устанавливает флаг активности пользователя (`is_active`).

#### `POST /users/deactivate`
Деактивирует переданных пользователей и для всех открытых PR, где они были назначены ревьюверами, пытается найти активную замену из их команды.

#### `GET /users/getReview?user_id={user_id}`
Возвращает список Pull Request’ов, где пользователь назначен ревьювером.

### Pull Requests

#### `POST /pullRequest/create`
Создаёт Pull Request и автоматически назначает до 2 ревьюверов из команды автора.

#### `POST /pullRequest/merge`
Помечает Pull Request как `MERGED`.  
Операция идемпотентна.

#### `POST /pullRequest/reassign`
Переназначает конкретного ревьювера в Pull Request на другого участника из той же команды.

Подробности можно посмотреть в openApi документации

---

### Проблемы, с которыми столкнулся

##### 1.
- Проблема:
    - Автогенерированный OpenAPI-интерфейс требует одной структуры-обработчика для всех эндпоинтов, что приводит к громоздкому и неудобному для поддержки коду.
- Задача:
    - Разделить бизнес-логику по доменным областям, сохранив совместимость с единым OpenAPI-интерфейсом.
- Действия:
    - Вынес доменные обработчики (PullRequest, Team, User) в отдельные пакеты с чистой бизнес-логикой.
    - Реализовал агрегирующий Api, который делегирует вызовы соответствующим handler’ам и удовлетворяет OpenAPI-интерфейсу.
- Результат:
    - Архитектура стала чистой, легко масштабируемой и поддерживаемой, а сервис полностью совместим с автогенерируемым OpenAPI-сервером.

##### 2.
- Задача:
    - Нужно автоматически назначать до двух случайных ревьюверов из команды автора без повторов и с равномерным распределением.
    - Выбрать алгоритм, который эффективно работает на больших командах выбирает `n` уникальных случайных элементов из массива, не перемешивая весь массив и не создавая лишних структур данных.

- Решение:
    - Я использовал алгоритм Фишера–Йетса, потому что:
        - В отличие от `rand.Shuffle` он не перемешивает весь массив, а делает ровно `n` замен;
        - В отличие от подходов с `map` он не требует дополнительной памяти;

- Результат:
  Назначение ревьюверов стало равномерным и выполняется за `O(1)` даже на больших командах.

##### 3.
- Проблема:
    - При реализации эндпоинта `users/deactivate` все операции надо провести в рамках одной транзакции, но приходилось либо описывать всю логику в репозиторном слое, либо делать отдельную кучу методов для проброса транзакции.

- Действия:
    - Начал изучать возможные решения и наткнулся на статью на хабре про [менеждер транзакций](https://habr.com/ru/companies/avito/articles/727168/). Изучив принципы работы, принял решение, что это именно то, что нужно для решения моей проблемы.
    - Менеджер управляет границами транзакций сам — из сервисного слоя вызывается одна функция `Do(...)`, а методы репозитории остаются чистыми
    - Можно реализовывать всю бизнес логику в сервисном слое, без создания большого количества дополнительных методов в сервисном слое.
    - Убирает дублирующийся код

- Результат:
    - Вся логика требующая транзакций вынесена в сервисный слой
    - Тесты легко пишутся — можно мокать менеджер, проверять “всё или ничего”.
    - Нет пробрасывания транзакций по всему коду, повышена читаемость и простота.

---

### CI/CD

Проект использует GitHub Actions. Основные workflow:

- **CI** (`.github/workflows/ci.yml`) - проверяет код при каждом push и pull request
    - Запуск линтера golangci-lint
    - Запуск unit-тестов
---

### Конфигурация линтера (golangci-lint)

**Линтер автоматически запускается через Taskfile и в CI (GitHub Actions).**

Посмотреть конфирурацию линтера можно [тут](linter-cfg.md)
